#version 450 core

layout(location = 0) in vec3 position;
layout(location = 1) in vec4 color;

layout(location = 2) in vec3 objectPosition;
layout(location = 3) in vec4 objectRotation;
layout(location = 4) in vec3 objectSize;

uniform vec4 cameraRotation;
uniform vec3 cameraPosition;
uniform vec3 cameraSize;
uniform float cameraFOV;

uniform float aspectRatio;
uniform float nearPlane;
uniform float farPlane;

out vec4 vertColor;

vec4 multiplyQuat(vec4 p1, vec4 p2) {
    return vec4(
    p1.w * p2.x + p1.x * p2.w + p1.y * p2.z - p1.z * p2.y,
    p1.w * p2.y + p1.y * p2.w + p1.z * p2.x - p1.x * p2.z,
    p1.w * p2.z + p1.z * p2.w + p1.x * p2.y - p1.y * p2.x,
    p1.w * p2.w - p1.x * p2.x - p1.y * p2.y - p1.z * p2.z
    );
}

vec3 rotatePoint(vec3 point, vec4 rotation) {
    float norm = length(rotation.xyz);
    vec4 NormRotation;
    NormRotation = rotation / norm;

    vec3 axis = NormRotation.xyz;
    float angle = radians(NormRotation.w);
    axis = normalize(axis);

    vec4 quaternion = vec4(
        axis.x * sin(angle / 2.0),
        axis.y * sin(angle / 2.0),
        axis.z * sin(angle / 2.0),
        cos(angle / 2.0)
    );

    vec4 quaternionConjugated = vec4( -quaternion.x, -quaternion.y, -quaternion.z, quaternion.w );

    vec4 purePoint = vec4(point.x, point.y , point.z, 0);

    vec4 globalPoint = multiplyQuat(multiplyQuat(quaternion, purePoint), quaternionConjugated);
    return globalPoint.xyz;
}

vec3 perspective(vec3 position, float degFOV, float aspect, float nearP, float farP) {
    float radFOV = radians(degFOV);
    vec2 range = vec2(
        tan(radFOV / 2) * position.z,
        tan((radFOV * (1 / aspect)) / 2) * position.z
        );

    vec3 newPosition = vec3(
        position.x / range.x,
        position.y / range.y,
        position.z / (nearP + farP)
        );

    return newPosition;
}

void main() {
    vec4 cameraROT = cameraRotation;
    vec3 cameraPOS = cameraPosition;
    vec4 objectROT = objectRotation;
    vec3 objectPOS = objectPosition;

    vec3 newPosition = position * objectSize;;

    if (cameraROT.x == 0 &&
        cameraROT.y == 0 &&
        cameraROT.z == 0)
        cameraROT = vec4 (0, 0, 1, 0);
    if (objectROT.x == 0 &&
        objectROT.y == 0 &&
        objectROT.z == 0)
        objectROT = vec4 (0, 0, 1, 0);

    vec3 worldPos = rotatePoint(newPosition, objectROT) + objectPOS;
    vec4 cameraConj = vec4( -cameraROT.x, -cameraROT.y, -cameraROT.z, cameraROT.w );
    vec3 camSpacePos = rotatePoint(worldPos - cameraPOS, cameraConj);

    camSpacePos /= cameraSize;

    gl_Position = vec4(perspective(camSpacePos, cameraFOV, aspectRatio, nearPlane, farPlane), 1.0);

    vertColor = color;
}